//! Confuse-Fuzz
//!
//! This library contains abstractions over a fuzzing campaign using the SIMICS platform

pub mod message;

extern crate num_traits;
#[macro_use]
extern crate num_derive;

use anyhow::{Context, Error, Result};
use std::collections::HashSet;

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, FromPrimitive, Hash, PartialEq, Eq, Copy, Clone)]
#[repr(i64)]
/// An X86 CPU Fault. Faults are generated by SIMICS' `Core_Exception` HAP and checked
/// against a set of faults that are considered crashes for a given fuzzing campaign. Most
/// of these faults are self-explanatory or documented in the SDM
pub enum Fault {
    /// Triple Fault
    ///
    /// Triple fault doesn't have a number, so we choose -1 which will never be the exception
    /// number
    Triple = -1,
    Division = 0,
    Debug = 1,
    NonMaskableInterrupt = 2,
    Breakpoint = 3,
    Overflow = 4,
    BoundRangeExceeded = 5,
    InvalidOpcode = 6,
    DeviceNotAvailable = 7,
    Double = 8,
    InvalidTss = 10,
    SegmentNotPresent = 11,
    StackSegment = 12,
    GeneralProtection = 13,
    Page = 14,
    X86Fpe = 16,
    AlignmentCheck = 17,
    MachineCheck = 18,
    SimdFpen = 19,
    VirtualizationException = 20,
    ControlProtectionException = 21,
}

impl TryFrom<i64> for Fault {
    type Error = Error;

    /// Try to convert an i64 to a fault and fail if the number is unknown
    fn try_from(value: i64) -> Result<Self> {
        num::FromPrimitive::from_i64(value).context("Could not convert to Fault")
    }
}

#[derive(Debug, Serialize, Deserialize)]
/// Information passed to the Confuse SIMICS module on initialization. This information is
/// passed only once, before the start harness is hit, and contains information about the fuzzing
/// campaign as a whole
pub struct InitInfo {
    /// The set of faults that are considered crashes for this fuzzing campaign
    pub faults: HashSet<Fault>,
    /// The duration after the start harness to treat as a timeout, in microseconds
    /// (1/1000000 seconds). Use `set_timeout_seconds` or `set_timeout_milliseconds` instead of
    /// doing the math yourself!
    pub timeout: u64,
}

impl InitInfo {
    /// Add a fault to the set of faults considered crashes for a given fuzzing campaign
    pub fn add_fault(&mut self, fault: Fault) {
        self.faults.insert(fault);
    }

    /// Add one or more faults to the set of faults considered crashes for a given fuzzing
    /// campaign
    pub fn add_faults<I: IntoIterator<Item = Fault>>(&mut self, faults: I) {
        faults.into_iter().for_each(|i| {
            self.faults.insert(i);
        });
    }

    /// Set the timeout in seconds
    pub fn set_timeout_seconds(&mut self, seconds: u64) {
        self.timeout = seconds * 1000 * 1000;
    }

    pub fn set_timeout_milliseconds(&mut self, milliseconds: u64) {
        self.timeout = milliseconds * 1000;
    }

    pub fn set_timeout_microseconds(&mut self, microseconds: u64) {
        self.timeout = microseconds;
    }
}

impl Default for InitInfo {
    /// Initializes the initialization info struct with sane defaults (no faults enabled)
    fn default() -> Self {
        Self {
            // Default to no faults
            faults: HashSet::new(),
            // Default timeout to 60 seconds
            timeout: 60 * 1000 * 1000,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
/// Each time the simulation stops, a stop type must be used to determine whether the stop is
/// normal, a crash, or a timeout (timeouts cannot be monitored by the fuzzer because the
/// simulator does not run at wall clock speeds, they MUST be monitored by SIMICS). In all cases
/// a snapshot will be reverted to, but we need this information to inform the fuzzer objectives
pub enum StopType {
    /// A normal stop due to either simulation exit or hitting the stop harness.
    Normal,
    /// A crash occurred
    Crash(Fault),
    /// A timeout occurred
    TimeOut,
}
