extern crate num_traits;
// #[macro_use]
// extern crate num_derive;
use num_derive::FromPrimitive;

use anyhow::{Context, Error, Result};
use ipc_shm::IpcShm;
use std::collections::HashSet;

use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, FromPrimitive, Hash, PartialEq, Eq, Copy, Clone)]
#[repr(i64)]
/// An X86 CPU Fault. Faults are generated by SIMICS' `Core_Exception` HAP and checked
/// against a set of faults that are considered crashes for a given fuzzing campaign. Most
/// of these faults are self-explanatory or documented in the SDM
pub enum Fault {
    /// Triple Fault
    ///
    /// Triple fault doesn't have a number, so we choose -1 which will never be the exception
    /// number
    Triple = -1,
    Division = 0,
    Debug = 1,
    NonMaskableInterrupt = 2,
    Breakpoint = 3,
    Overflow = 4,
    BoundRangeExceeded = 5,
    InvalidOpcode = 6,
    DeviceNotAvailable = 7,
    Double = 8,
    InvalidTss = 10,
    SegmentNotPresent = 11,
    StackSegment = 12,
    GeneralProtection = 13,
    Page = 14,
    X86Fpe = 16,
    AlignmentCheck = 17,
    MachineCheck = 18,
    SimdFpen = 19,
    VirtualizationException = 20,
    ControlProtectionException = 21,
}

impl TryFrom<i64> for Fault {
    type Error = Error;

    /// Try to convert an i64 to a fault and fail if the number is unknown
    fn try_from(value: i64) -> Result<Self> {
        num::FromPrimitive::from_i64(value).context("Could not convert to Fault")
    }
}

#[derive(Debug, Serialize, Deserialize)]
/// Information passed to the Confuse SIMICS module on initialization. This information is
/// passed only once, before the start harness is hit, and contains information about the fuzzing
/// campaign as a whole
pub struct InitInfo {
    /// The set of faults that are considered crashes for this fuzzing campaign
    pub faults: HashSet<Fault>,
    /// The duration after the start harness to treat as a timeout, in seconds
    /// Use `set_timeout_seconds` or `set_timeout_milliseconds` instead of
    /// doing the math yourself!
    pub timeout: f64,
}

impl InitInfo {
    /// Add a fault to the set of faults considered crashes for a given fuzzing campaign
    pub fn add_fault(&mut self, fault: Fault) {
        self.faults.insert(fault);
    }

    /// Add one or more faults to the set of faults considered crashes for a given fuzzing
    /// campaign
    pub fn add_faults<I: IntoIterator<Item = Fault>>(&mut self, faults: I) {
        faults.into_iter().for_each(|i| {
            self.faults.insert(i);
        });
    }

    /// Set the timeout in seconds
    pub fn set_timeout_seconds(&mut self, seconds: f64) {
        self.timeout = seconds;
    }

    pub fn set_timeout_milliseconds(&mut self, milliseconds: f64) {
        self.timeout = milliseconds / 1000.0;
    }

    pub fn set_timeout_microseconds(&mut self, microseconds: f64) {
        self.timeout = microseconds / 1_000_000.0;
    }
}

impl Default for InitInfo {
    /// Initializes the initialization info struct with sane defaults (no faults enabled)
    fn default() -> Self {
        Self {
            // Default to no faults
            faults: HashSet::new(),
            // Default timeout to 60 seconds
            timeout: 60.0 * 1000.0 * 1000.0,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
/// Each time the simulation stops, a stop type must be used to determine whether the stop is
/// normal, a crash, or a timeout (timeouts cannot be monitored by the fuzzer because the
/// simulator does not run at wall clock speeds, they MUST be monitored by SIMICS). In all cases
/// a snapshot will be reverted to, but we need this information to inform the fuzzer objectives
pub enum StopType {
    /// A normal stop due to either simulation exit or hitting the stop harness.
    Normal,
    /// A crash occurred
    Crash(Fault),
    /// A timeout occurred
    TimeOut,
}

#[derive(Debug, Serialize, Deserialize)]
/// Events the fuzzer generates that SIMICS consumes
pub enum FuzzerEvent {
    /// Initialize event, the fuzzer signals the Confuse SIMICS module to initialize itself with
    /// a given set of global campaign settings
    Initialize(InitInfo),
    /// The fuzzer signals the Confuse SIMICS module to run with a given input of bytes
    Run(Vec<u8>),
    /// The fuzzer signals the Confuse SIMICS module to reset to the start snapshot
    Reset,
    /// The fuzzer signals the Confuse SIMICS module to stop execution and exit
    Stop,
}

#[derive(Debug, Serialize, Deserialize)]
/// Events SIMICS generates that the fuzzer consumes
pub enum SimicsEvent {
    /// Simics signals the fuzzer that it is ready to run
    Ready,
    /// Simics signals the fuzzer that it has stopped and why
    Stopped(StopType),
    /// Simics signals the fuzzer that it is done executing.
    Done,
    /// Simics sends the AFL map shared memory to the fuzzer
    SharedMem(IpcShm),
}

#[derive(Debug, Serialize, Deserialize)]
/// A wrapper for either a Fuzzer or SIMICS event
pub enum Message {
    FuzzerEvent(FuzzerEvent),
    SimicsEvent(SimicsEvent),
}
